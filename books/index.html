<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>University of Minnesota Twin Cities PL Seminar</title>
		
		<link rel="stylesheet" href="https://umn-plseminar.github.io/css/main.min.db9c9c28c2c7c44b7225f2bd9789b3ff87cf3b828b24f711cba4e1c958acd9f1.css" integrity="sha256-25ycKMLHxEtyJfK9l4mz/4fPO4KLJPcRy6ThyVis2fE="/>
	</head>
	<body>
		<main>
			<header>
				<h1><a href="https://umn-plseminar.github.io/">University of Minnesota Twin Cities PL Seminar</a></h1>
				<nav>
					<a href="https://umn-plseminar.github.io/">Home</a>
					<a href="https://umn-plseminar.github.io/books/">Books</a>
					<a href="https://umn-plseminar.github.io/news/">News</a>
					<a href="https://groups.google.com/a/umn.edu/g/plseminar">Mailing List</a>
				</nav>
			</header>
			<section>
	<div class="section-title"><h2 id="things-weve-done-in-the-past">Things we&#39;ve done in the past</h2></div>
	<div class="section-content"><ul>
<li>Term <em>Re</em>writing and <em>All That</em>
<ul>
<li>Baader and Nipkow 1998</li>
<li>An introduction to term rewriting systems.</li>
<li>Contains SML code</li>
<li>11ch, 301pgs</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> [Sep 2022 thru Dec 2022]
<ul>
<li>Klabnik and Nichols</li>
<li>Online book</li>
<li>21ch</li>
</ul>
</li>
<li><a href="https://arxiv.org/abs/1803.05316">Seven Sketches in Compositionality</a> [May 2021 thru Aug 2021]
<ul>
<li>Fong and Spivak 2019</li>
<li>Category theory book where the examples are gentler than other books we&rsquo;ve tried</li>
<li><a href="https://arxiv.org/pdf/1803.05316.pdf">PDF</a></li>
<li>7ch, 353pgs</li>
</ul>
</li>
<li><a href="https://mitpress.mit.edu/9780262691635/the-art-of-prolog/">The Art of Prolog</a> [Sept 2020 thru April 2021]
<ul>
<li>Sterling and Shapiro 1994</li>
<li>A book starting at Prolog basics, and getting up to cool metaprogramming tricks, including Prolog interpreters in Prolog, compilers and planners, etc.</li>
<li>24ch, 552pgs.</li>
</ul>
</li>
<li><a href="https://softwarefoundations.cis.upenn.edu/lf-current/index.html">Logical Foundations</a> [Jan 2020 thru July 2020]
<ul>
<li>Pierce et al Ongoing</li>
<li>The first of &ldquo;the&rdquo; Coq for PLT book series, Software Foundations</li>
<li>17ch</li>
</ul>
</li>
<li><a href="https://www.manning.com/books/type-driven-development-with-idris">Type Driven Development with Idris</a> [Sep 2019 thru Jan 2020]
<ul>
<li>Brady 2017</li>
<li>An introduction to dependently typed programming in Idris.</li>
<li>15ch, 480pgs</li>
</ul>
</li>
<li><a href="https://thelittletyper.com/">The Little Typer</a> [July 2019 thru Sep 2019]
<ul>
<li>Friedman and Christiansen 2018</li>
<li>An introduction to dependent types with Pie.</li>
<li>16ch, 242pgs</li>
</ul>
</li>
<li><a href="https://math.jhu.edu/~eriehl/context/">Category Theory in Context</a> [May 2019 thru July 2019 (gave up&hellip;)]
<ul>
<li>Riehl 2016</li>
<li>The first category book we tried. It didn&rsquo;t go well. (Written for mathematicians, not programmers!)</li>
<li>6ch, 272pgs</li>
</ul>
</li>
<li><a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a> [Sep 2017 thru July 2018]
<ul>
<li>Pierce 2002</li>
<li>A very solid introduction to type systems for lambda calculi (including ones with object-oriented extensions) and programming language theory.</li>
<li>Introduces common notation used in PL papers very well.</li>
<li>This is probably worth doing every few years!</li>
<li>32ch, 648pgs</li>
</ul>
</li>
</ul>
</div>
</section>

<section>
	<div class="section-title"><h2 id="books-we-might-want-to-read-in-the-future">Books we might want to read in the future</h2></div>
	<div class="section-content"><ul>
<li><a href="https://jfr.unibo.it/article/view/4650">Abella: A System for Reasoning about Relational Specifications</a>
<ul>
<li>Baelde, Chaudhuri, Gacek, Miller, Nadathur, Tiu, and Wang 2014</li>
<li>A tutorial for Abella.</li>
<li>I guess this is kinda a paper? It has chapters, so I&rsquo;m putting it here.</li>
<li>9ch, 89pgs.</li>
</ul>
</li>
<li>Algebra of Programming
<ul>
<li>Bird and de Moor 1997</li>
<li>BMF/Squiggol</li>
<li>10ch, 312pgs.</li>
</ul>
</li>
<li>Call-by-Push-Value
<ul>
<li>Levy 2003</li>
<li>Favonia said I should read it ages ago and it&rsquo;s been sitting it my TODO list ever since&hellip;</li>
<li><a href="https://www.cs.bham.ac.uk/~pbl/cbpv.html">FAQ</a></li>
<li>12ch, 381pgs.</li>
</ul>
</li>
<li>Category Theory for Programmers
<ul>
<li>Milewski 2019</li>
<li><a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Site</a>, <a href="https://github.com/hmemcpy/milewski-ctfp-pdf/">PDF</a>, <a href="http://www.blurb.com/b/9008339-category-theory-for-programmers">Hardcover</a>, <a href="https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Lectures</a></li>
<li>What it says on the tin</li>
<li>Covers more than Seven Sketches in Compositionality</li>
<li>Contains Haskell code</li>
<li>31ch, 498pgs.</li>
</ul>
</li>
<li><a href="https://github.com/achlipala/frap">Formal Reasoning About Programs</a>
<ul>
<li>Chlipala Ongoing</li>
<li>Coq book getting to the nice PL stuff sooner than SF</li>
<li>Open source! (CC and BSD)</li>
<li>19ch, online (as of May 2021).</li>
</ul>
</li>
<li><a href="http://t3x.org/klong/book.html">An Introduction to Array Programming in Klong</a>
<ul>
<li>Holm 2018</li>
<li>Array programming as in APL, J, K, or Q.</li>
<li><a href="http://t3x.org/klong/ap-excerpt.pdf">Sample</a></li>
<li>3ch, 100pgs.</li>
</ul>
</li>
<li>Lisp in Small Pieces
<ul>
<li>Queinnec 1994</li>
<li>Essentially a series of tutorials on different ways to implement Lisp (and Scheme), and goes into some of the design decisions involved.</li>
<li>My introduction to continuations and denotational semantics.</li>
<li>11ch, 514pgs.</li>
</ul>
</li>
<li><a href="https://leanprover.github.io/logic_and_proof/index.html">Logic and Proof</a>
<ul>
<li>Avigad, Lewis, and van Doorn 2017</li>
<li>The more mathy Lean book (the other is Theorem Proving in Lean, below).</li>
<li>24ch, online.</li>
</ul>
</li>
<li><a href="https://doi.org/10.5281/zenodo.3999478">Mathematical Components</a>
<ul>
<li>Mahboubi and Tassi, Ongoing</li>
<li>Coq book teaching the Coq/SSReflect language, covering mostly math (rather than PLT)</li>
<li>Open source! (CC-BY-NC)</li>
<li>8ch, 187pgs.</li>
</ul>
</li>
<li>Object-Oriented Programming in Common Lisp
<ul>
<li>Keene 1988</li>
<li>An introduction to CLOS; if you think you know OOP and haven&rsquo;t used CLOS, you should give it a try!</li>
<li>12ch, 288pgs.</li>
</ul>
</li>
<li>Optics By Example
<ul>
<li>Penner 2020</li>
<li>Lenses, Prisms, etc. in Haskell</li>
<li>20ch, 420pgs.</li>
</ul>
</li>
<li><a href="http://www.itu.dk/people/sestoft/pebook/">Partial Evaluation and Automatic Program Generation</a>
<ul>
<li>Jones, Gomard, and Sestoft 1999</li>
<li>What it says on the tin.</li>
<li>Implements very cool programs in surprisingly little code.</li>
<li>18ch, 425pgs.</li>
</ul>
</li>
<li><a href="https://github.com/SquareBracketAssociates/PharoByExample80">Pharo by Example</a>
<ul>
<li>Various, Ongoing</li>
<li>Open source! (CC-BY-SA)</li>
<li><a href="https://github.com/SquareBracketAssociates/PharoByExample80/releases/download/continuous/PBE8-wip.pdf">PDF</a></li>
<li>17ch, 312pgs (as of May 2021).</li>
</ul>
</li>
<li><a href="https://www.cs.cmu.edu/~rwh/pfpl/">Practical Foundations for Programming Languages</a>
<ul>
<li>Harper 2016</li>
<li>Seems TAPL-shaped?</li>
<li>18ch, 580pgs.</li>
</ul>
</li>
<li>Principles of Program Analysis
<ul>
<li>Nielson, Nielson, and Hankin 2005 (2nd printing)</li>
<li>Covers control flow and data flow analyses, and abstract interpretation.</li>
<li>Might be fun to implement along with the book.</li>
<li>6ch, 452pgs.</li>
</ul>
</li>
<li>Program Design by Calculation
<ul>
<li>Oliveira 2021/Ongoing</li>
<li>BMF/Squiggol book, allegedly better presentation than Algebra of Programming, but still a draft</li>
<li>Being continuously updated</li>
<li>Lots of material covered in <a href="https://www-users.cs.umn.edu/~evw/teaching/fadc.html">Eric&rsquo;s Spring 2021 CSCI8980</a>, so we might wanna hold off until it&rsquo;s out of people&rsquo;s recent memory.</li>
<li><a href="https://www4.di.uminho.pt/~jno/ps/pdbc.pdf">PDF</a></li>
<li>10ch, 313pgs (as of Feb 2021).</li>
</ul>
</li>
<li><a href="https://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/program-logics-certified-compilers">Program Logics for Certified Compilers</a>
<ul>
<li>Appel 2014</li>
<li>Separation logic, from the CompCert people</li>
<li><a href="https://vst.cs.princeton.edu/PLCC-sample.pdf">Sample</a></li>
<li>46ch, 472pgs.</li>
</ul>
</li>
<li>Programming with Higher-Order Logic
<ul>
<li>Miller and Nadathur 2012</li>
<li>The λProlog book</li>
<li>11ch, 320pgs.</li>
</ul>
</li>
<li><a href="https://mitpress.mit.edu/books/reasoned-schemer">The Reasoned Schemer</a>
<ul>
<li>Friedman, Byrd, and Kiselyov 2005 (1st ed)</li>
<li>MiniKanren. Easier to implement than Prolog, not depth-first-search-by-default.</li>
<li>Written as a dialogue.</li>
<li>If we do this, there&rsquo;s a bunch of really cool miniKanren papers I&rsquo;d like after, including a couple neat program-synthesis things.</li>
<li>12ch, 169pgs.</li>
</ul>
</li>
<li><a href="https://mitpress.mit.edu/books/software-abstractions-revised-edition">Software Abstractions</a>
<ul>
<li>Jackson 2011</li>
<li>The Alloy tutorial; <a href="https://www.youtube.com/watch?v=FvNRlE4E9QQ">this talk</a> sold me on this being really cool.</li>
<li>6ch, 376pgs.</li>
</ul>
</li>
<li>The TeXbook
<ul>
<li>Knuth 1984</li>
<li>27ch, 496pgs.</li>
</ul>
</li>
<li><a href="https://leanprover.github.io/theorem_proving_in_lean/">Theorem Proving in Lean</a>
<ul>
<li>Avigad, de Moura, and Kong 2017</li>
<li>The more CSy Lean book (the other is Logic and Proof, above).</li>
<li>11ch, online.</li>
</ul>
</li>
<li>Warren&rsquo;s Abstract Machine: A Tutorial Reconstruction
<ul>
<li>Aït-Kaci 1991</li>
<li>A more readable version of An Abstract Prolog Instruction Set, essentially.</li>
<li>However, last time I tried to read it, I found enough errata that it&rsquo;s not as <em>directly</em> useful as an implementation guide as it could be.</li>
<li>Still, good for the 10,000-foot view.</li>
<li>6ch, 114pgs.</li>
</ul>
</li>
</ul>
</div>
</section>

<section>
	<div class="section-title"><h2 id="papers-we-might-want-to-read-in-the-future">Papers we might want to read in the future</h2></div>
	<div class="section-content"><ul>
<li>An Abstract Prolog Instruction Set
<ul>
<li>Warren 1983</li>
<li>Initial presentation of the Warren Abstract Machine; I&rsquo;ve been warned this is less than completely clear, but never read it.</li>
<li>34pgs, so maybe avoid or split up.</li>
</ul>
</li>
<li>An Algorithm for Optimal Lambda Calculus Reduction
<ul>
<li>Lamping 1990</li>
<li>Initial presentation of interaction nets, I think?</li>
<li>16pgs, 4 of which are pictures.</li>
</ul>
</li>
<li><a href="https://www.microsoft.com/en-us/research/publication/build-systems-a-la-carte/">Build systems a la carte: theory and practice</a>
<ul>
<li>Mokhov 2020</li>
<li>Compares build systems and breaks them down into components, then prototypes new ones from the components</li>
<li>Covers Make, Excel, Shake, and Bazel</li>
<li>Revised + expanded version of original &ldquo;Build systems a la carte&rdquo; (Mokhov 2018)</li>
</ul>
</li>
<li><a href="https://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf">Call-by-Value is Dual to Call-by-Name</a>
<ul>
<li>Wadler 2003</li>
<li>13pgs.</li>
</ul>
</li>
<li>Clowns to the Left of me, Jokers to the Right
<ul>
<li>McBride 2008</li>
<li>A generalization of zippers to allow representing a computation in progress.</li>
</ul>
</li>
<li>Functional Pearl: Data types a la carte
<ul>
<li>Sweirstra 2008</li>
<li>Recursion schemes-like machinery for extensible types.</li>
<li>14pgs.</li>
</ul>
</li>
<li>The Gentle Art of Levitation
<ul>
<li>Chapman 2010</li>
<li>Datatypes, including induction, without needing a special declaration type or anything.
(Stahl is doing a variation of this, for which induction is sadly trickier&hellip;)</li>
<li>12 pgs.</li>
</ul>
</li>
<li>Ghosts of Departed Proofs (Functional Pearl)
<ul>
<li>Noonan 2018</li>
<li>Proof-checked code in Haskell with a tasteful set of extensions (i.e., not like <a href="https://twitter.com/edwinbrady/status/1163816732902883329">this</a>).</li>
</ul>
</li>
<li>Hoopl: A Modular, Reusable Library for Dataflow Analysis and Tranformation
<ul>
<li>Ramsey 2010</li>
<li>What it says on the tin.</li>
<li>16 pgs.</li>
</ul>
</li>
<li>Monad Transformers and Modular Algebraic Effects: What Binds Them Together
<ul>
<li>Schrijvers 2019</li>
<li>Random algebraic effects paper.</li>
<li>17pgs, 2 of which are cover pages, 3 of which are appendices.</li>
</ul>
</li>
<li>Quick Compilers Using Peephole Optimization
<ul>
<li>Davidson 1989</li>
<li>Turns out peephole optimization has a really really high payoff vs effort to implement (as the only optimization the compiler does, at least).</li>
<li>22 pgs, 5 of which are appendices and some chunk of which is describing a quite cursed pattern matching engine.
(This is from before computers were fast, so I suppose <code>sed</code>ing the assembly was too slow?)</li>
</ul>
</li>
<li>Selective Applicative Functors
<ul>
<li>Mokhov 2019</li>
<li>An extension of applicative functors to add choice, which lets them replace monads in some circumstances.</li>
<li>29 pgs.</li>
</ul>
</li>
<li>Sequent Calculus as a Compiler Intermediate Language
<ul>
<li>Downen 2016</li>
<li>What it says on the tin, as a replacement for GHC Core.</li>
<li>15 pgs.</li>
</ul>
</li>
<li>A tutorial implementation of dynamic pattern unification
<ul>
<li>Gundry 2012</li>
<li>A tutorial of implementing metavariables in a dependently-typed language.</li>
<li>Contains Haskell code</li>
<li>Yeah, this one&rsquo;s transparently from my &ldquo;to read&rdquo; bucket.</li>
</ul>
</li>
<li>There is no Fork: an Abstraction for Efficient, Concurrent, and Concise Data Access
<ul>
<li>Marlow 2014</li>
<li>Smarter IO behavior when IO is done in applicatives (which don&rsquo;t include ordering).</li>
<li>13 pgs.</li>
</ul>
</li>
<li><a href="https://doi.org/10.1145/3110252">A Unified Approach to Solving Seven Programming Problems (functional pearl)</a>
<ul>
<li>Byrd, Ballantyne, Rosenblatt, and Might 2017</li>
<li>Some really cool code synthesis stuff in miniKanren</li>
<li>26pgs.</li>
</ul>
</li>
<li>Yacc is Dead
<ul>
<li>Might 2010</li>
<li>A parsing algorithm using Brzozowski derivatives, much easier to implement than LALR (comparable to a middling-efficiency regex engine, iirc).</li>
<li>We might&rsquo;ve already done this a couple years ago, but I don&rsquo;t remember.</li>
<li>18pgs.</li>
</ul>
</li>
</ul>
</div>
</section>

<section>
	<div class="section-title"><h2 id="other-resources">Other resources</h2></div>
	<div class="section-content"><ul>
<li>Nathan Ringo runs a Forth workshop
<ul>
<li>Probably something like, 2-3 weeks on learning the language, 1 week on a &ldquo;metacircular&rdquo; implementation, 1 week on bootstrapping, 2-3 weeks on advanced topics</li>
</ul>
</li>
<li>OPLSS 2015 - Logical Relations
<ul>
<li>Video lectures about proving &ldquo;difficult to prove&rdquo; properties, e.g. strong normalization of STLC</li>
<li><a href="https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html">Info Site</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLiHLLF-foEex7BOvMbrbUFC9XgU7fZW66">Videos</a></li>
</ul>
</li>
</ul>
</div>
</section>


			<div class="spacer"></div>
			<footer>
				<span>Content licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license">CC BY-SA 4.0</a></span>
				<span>Edit this site <a href="https://github.com/umn-plseminar/umn-plseminar.github.io">on GitHub</a></span>
				<span>Last modified on January 1, 0001</span>
			</footer>
		</main>
	</body>
</html>
